"""
Pydantic Schemas
================

Defines data validation and serialization schemas.

Why separate from SQLAlchemy models?
- SQLAlchemy models = Database tables (what's stored)
- Pydantic schemas = API contracts (what's sent/received)

Schema naming convention:
- *Create: Data needed to create a resource
- *Update: Data for updating (usually optional fields)
- *Response: Data returned to client
- *InDB: Database representation (includes auto-generated fields)

Example flow:
1. Client sends JSON → ProductCreate validates it
2. Create database record → SQLAlchemy model
3. Return to client → Product (response) serializes it
"""

from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional
from datetime import datetime

# ============================================================================
# PRODUCT SCHEMAS
# ============================================================================

class ProductBase(BaseModel):
    """
    Base product fields (shared across schemas).
    
    Why a base class?
    - DRY principle (Don't Repeat Yourself)
    - Common fields defined once
    - Inherited by Create, Update, Response
    """
    name: str = Field(..., min_length=1, max_length=200, description="Product name")
    description: Optional[str] = Field(None, description="Product description")
    price: float = Field(..., gt=0, description="Price in USD (must be positive)")
    stock: int = Field(default=0, ge=0, description="Available stock (non-negative)")


class ProductCreate(ProductBase):
    """
    Schema for creating a new product.
    
    Request body example:
    {
        "name": "iPhone 15",
        "description": "Latest Apple smartphone",
        "price": 999.99,
        "stock": 50
    }
    
    Validation:
    - name: Required, 1-200 characters
    - price: Required, must be > 0
    - stock: Optional (defaults to 0), must be >= 0
    - description: Optional
    """
    pass  # Inherits everything from ProductBase


class ProductUpdate(BaseModel):
    """
    Schema for updating a product (all fields optional).
    
    Request body example (partial update):
    {
        "price": 899.99,
        "stock": 75
    }
    
    Why all optional?
    - Allows partial updates (only change what you want)
    - Client doesn't need to send all fields
    """
    name: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    price: Optional[float] = Field(None, gt=0)
    stock: Optional[int] = Field(None, ge=0)


class Product(ProductBase):
    """
    Schema for product responses (what API returns).
    
    Response example:
    {
        "id": 1,
        "name": "iPhone 15",
        "description": "Latest Apple smartphone",
        "price": 999.99,
        "stock": 50,
        "created_at": "2026-02-20T10:30:00Z",
        "updated_at": "2026-02-20T10:30:00Z"
    }
    
    Includes read-only fields:
    - id: Generated by database
    - created_at, updated_at: Auto-managed timestamps
    """
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    # Pydantic v2 configuration
    model_config = ConfigDict(from_attributes=True)
    # from_attributes=True allows: Product.model_validate(sqlalchemy_obj)


# ============================================================================
# ORDER ITEM SCHEMAS
# ============================================================================

class OrderItemBase(BaseModel):
    """Base order item fields."""
    product_id: int = Field(..., gt=0, description="ID of product to order")
    quantity: int = Field(..., gt=0, description="Quantity (must be positive)")


class OrderItemCreate(OrderItemBase):
    """
    Schema for adding item to order.
    
    Request body example:
    {
        "product_id": 1,
        "quantity": 2
    }
    
    Note: price_at_purchase is calculated server-side
    """
    pass


class OrderItem(OrderItemBase):
    """
    Schema for order item response.
    
    Response example:
    {
        "id": 1,
        "product_id": 1,
        "quantity": 2,
        "price_at_purchase": 999.99
    }
    """
    id: int
    order_id: int
    price_at_purchase: float
    
    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# ORDER SCHEMAS
# ============================================================================

class OrderBase(BaseModel):
    """Base order fields."""
    user_id: int = Field(..., gt=0, description="Customer ID")


class OrderCreate(OrderBase):
    """
    Schema for creating an order.
    
    Request body example:
    {
        "user_id": 42,
        "items": [
            {"product_id": 1, "quantity": 2},
            {"product_id": 3, "quantity": 1}
        ]
    }
    
    Validation:
    - user_id: Required, must be positive
    - items: At least one item required
    - Each item validated by OrderItemCreate
    """
    items: List[OrderItemCreate] = Field(..., min_length=1, description="Order items")


class Order(OrderBase):
    """
    Schema for order response.
    
    Response example:
    {
        "id": 1,
        "user_id": 42,
        "total_amount": 2999.97,
        "status": "pending",
        "created_at": "2026-02-20T10:30:00Z",
        "items": [
            {
                "id": 1,
                "product_id": 1,
                "quantity": 2,
                "price_at_purchase": 999.99
            },
            {
                "id": 2,
                "product_id": 3,
                "quantity": 1,
                "price_at_purchase": 999.99
            }
        ]
    }
    
    Includes nested items with full details.
    """
    id: int
    total_amount: float
    status: str
    created_at: datetime
    items: List[OrderItem] = []
    
    model_config = ConfigDict(from_attributes=True)


# ============================================================================
# SCHEMA USAGE EXAMPLES (for understanding)
# ============================================================================
#
# CREATE PRODUCT:
# @app.post("/products/", response_model=Product)
# def create_product(product: ProductCreate, db: Session = Depends(get_db)):
#     # product is validated ProductCreate object
#     db_product = models.Product(**product.model_dump())
#     db.add(db_product)
#     db.commit()
#     db.refresh(db_product)
#     return db_product  # Automatically serialized to Product schema
#
# GET PRODUCT:
# @app.get("/products/{id}", response_model=Product)
# def get_product(id: int, db: Session = Depends(get_db)):
#     product = db.query(models.Product).filter(models.Product.id == id).first()
#     return product  # Pydantic converts SQLAlchemy model → Product schema
#
# ============================================================================